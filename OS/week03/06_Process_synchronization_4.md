***지난시간 review )***

- Semaphore 문제점

  : P연산과 V연산을 통해 프로세스 동기화를 시행하지만, 이는 동기화 방법을 프로그래머한테 알려주고 프로그래머가 하기 때문에 프로그래머가 실수하게 되면 동기화가 깨져 치명적인 결과를 초래할 수 있음.

-> Monitor : 프로그래밍 언어 차원에서 공유데이터를 접근하는 문제를 모니터가 자동으로 해결하게 해줌으로써 프로그래머의 부담을 줄여주는 방법. 세마포어와 달리 lock을 걸 필요가 없음.

---

<br>

# Process Synchronization (4)

Process Synchronization (프로세스 동기화) = Concurrency Control (병행제어)

<br>

## 모니터 (Monitor)

세마포어 이후 프로세스 동기화 문제를 해결하기 위한 도구. 세마포어보다 고수준의 개념.

![image-20210328212232389](https://user-images.githubusercontent.com/77573938/112754465-34d5b380-9017-11eb-9e08-29d4ecdeec81.png)

- 프로세스가 공유데이터에 접근하려고 하면 모니터 안에 정의된 코드를 이용해서만 접근할 수 있게 만들어 놓음.
- 코드들이 공유데이터에 동시에 접근하면서 생기는 문제를 모니터가 애초에 발생하지 않게 막는다.
- 모니터는 active한 process **하나만이** 모니터 안의 코드를 실행할 수 있게 자체적으로 제어해준다. -> 모니터 내에서는 한번에 하나의 프로세스만이 활동 가능
- 모니터가 알아서 제어해주기 때문에 **lock을 걸 필요가 없다!!!** (세마포어와 차이점)
- 어떤 프로세스가 모니터 안에서 공유데이터를 접근하는 코드를 실행중이라면, 다른 프로세스는 entry queue에서 대기하게 된다. 모니터 안의 active한 프로세스의 수가 0이 되면, 모니터 밖에서 대기하던 프로세스가 안으로 들어와 공유데이터 코드를 실행할 수 있게 된다.



### condition variable 

프로세스가 모니터 안에서 기다릴 수 있도록 하기 위한 변수. 

어떤 조건을 만족하지 않아서 프로세스를 잠들게 할 목적으로 사용. -> wait과 signal 연산에 의해서만 접근 가능

- **`x.wait();`**  호출시, x라는 condition variable에 줄 서있게 된다. (즉, x에 프로세스를 **재우는** 역할)
- **`x.signal();`**  x라는 condition variable을 기다리면서 잠들어있는 프로세스 중 하나를 **깨워주는** 연산

<br>

## Bounded-Buffer Problem (생산자 소비자 문제)

![image-20210328220703000](https://user-images.githubusercontent.com/77573938/112754467-3606e080-9017-11eb-9bfb-f4bd4ed36a30.png)

- 생산자 프로세스 : 공유 버퍼에 자원을 만들어 넣어주는 프로세스
- 소비자 프로세스 : 공유 버퍼에서 데이터를 꺼내가는 프로세스

**모니터는 생산자든 소비자든 공유 buffer에 대해 lock/unlock 할 필요가 없게 해준다.**

단지 wait()와 signal()을 사용해 프로세스를 Block 시키고 Wakeup 시키는 작업만 해준다. 

- `full` : 내용이 들어있는 버퍼를 기다리면서 잠들게 하는 역할
- `empty` : 빈 버퍼를 기다리는 프로세스를 줄세우는 condition variable 



세마포어 변수는 값을 가지기 때문에 V 연산을 해주면 값이 1 증가한다. 

반면, 모니터는 잠들어 있는 프로세스를 깨우는 역할을 하기 때문에 signal을 해줬다고 해서 `full` 이라는 condition variable이 값을 가지지 않는다. 만약 내용이 들어있는 버퍼를 기다리면서 잠들어 있는 프로세스가 없다면 signal 연산에서 아무일도 일어나지 않는다.

<br>

## Dining Philosophers Example

식사하는 철학자들 문제는 전산학에서 동시성과 교착상태를 설명하는 예시로, 여러 프로세스가 동시에 돌아갈 때 교착 상태가 나타나는 원인을 직관적으로 알 수 있다.



[그림] 식사하는 철학자들 문제의 모니터 버전 코드

![image-20210328222828698](https://user-images.githubusercontent.com/77573938/112754469-369f7700-9017-11eb-97b4-f6ea0e536b5e.png)

밥을 먹기 위해서는 젓가락을 잡아야(pickup) 하고 먹은 후에는 젓가락을 놓아야(putdown) 한다.

젓가락이라는 공유자원을 접근하기 위해 모니터로 코드를 정리했다.

- `state[i]` : 모니터 안에서 공유데이터