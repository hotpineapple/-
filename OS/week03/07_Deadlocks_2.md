# Deadlocks (2)

## Avoidance 알고리즘

### 자원할당 그래프 알고리즘 (Resource Allocation Graph algorithm)

> 자원 당 인스턴스가 1개인 경우

자원 할당 그래프에 요청 간선과 할당 간선에 추가하여, 예약간선이라는 새로운 유형의 간선을 도입한다.

![image-20210328143929595](https://user-images.githubusercontent.com/77573938/112754633-effe4c80-9017-11eb-99e6-f617ceea185e.png)

- 점선 : (프로세스→자원으로만 나타난다) 프로세스가 평생에 적어도 한번 해당 자원을 사용(요청)할거라는 의미
- 실선 : 프로세스가 해당 자원을 요청한 경우

_EX)_ 마지막 그림의 경우 (P1이 R1을 가지고 있고, P2가 R2를 갖고 있는 상황) -> 데드락 (X)

why?  P1이 R2을 요청할 수는 있지만 지금 당장 요청한 것은 아니기 때문. 이 상황에서 요청을 한다면 점선이 실선으로 바뀌고 데드락이 된다.

<br>

### 은행원 알고리즘 (Banker's Algorithm)

> 자원 당 인스턴스가 여러 개인 경우

교착상태를 예측하여 교착상태가 가능한 상태는 자원을 할당하지 않는다.

- 가정 : **모든 프로세스는 자원의 최대 사용량을 미리 명시**하고, 프로세스가 요청자원을 모두 할당받은 경우 유한 시간 안에 자원을 다시 반납한다.

- 자원요청시 safe 상태를 유지할 경우에만 할당한다. == 총 요청 자원의 수가 가용자원의 수보다 적은 프로세스에만 할당
- 할당 받은 프로세스가 종료되면 모든 자원을 반납하고 모든 프로세스가 종료될 때까지 과정을 반복한다.



#### Example of Banker's Algorithm

![image-20210328151619916](https://user-images.githubusercontent.com/77573938/112754634-f096e300-9017-11eb-8b9f-146bffa962c0.png)

- safe sequence 존재
  - P1이 가용자원을 다 처리하고 반납하면, 그 반납한 자원을 가지고 P3가 가용 가능. 마찬가지로 P4, P2, P0의 순서로 `할당-반납`의 과정을 거치면 각 프로세스의 최대 요청 자원을 모두 충족하기 때문에 safe한 상태가 된다. 즉, 절대 데드락이 생기지 않는다.
- P0가 A를 1개 요청하면, available한 A가 3개이므로 줄 수 있다. 그럼 P0는 A를 1개 얻고, 가용자원은 1개가 줄어드는데 이 자체는 문제가 되지 않는다.
- safe한 상태에서 가용자원만으로 충족되지 않는 프로세스한테 자원을 줬다고 해서 데드락이 되는건 아니다! 이 상태에서 다른 프로세스들이 전부 최대 자원 요청을 할 경우 가용자원이 없어 데드락이 된다.

![image-20210328151834351](https://user-images.githubusercontent.com/77573938/112754636-f12f7980-9017-11eb-8d72-63003fb6b76b.png)

- P1이 A 1개, C 2개를 요청했다고 가정하면 `(1,0,2)` , A가 3개 C가 2개 남아있기 때문에 `(3,3,2)`가용자원(available)에서 프로세스를 줄 수 있는게 아니라 P1이 추가로 최대 요청할 수 있는 양(Need) `(1,2,2)`이 가용자원으로 모두 충족이 되기 때문에 주는 것이다.

- 반면, P0가 B를 2개 요청한 경우, B는 3개가 available하지만 P0가 추가로 요청할 수 있는 양이 4개이므로 자원을 주지 않는다. 

  **deadlock avoidance 방식은 최악의 상황을 가정**하므로 최대 요청의 경우로 고려해야 한다!

<br><br>

## 3. Deadlock Detection and Recovery

데드락이 생기지 않게 어떤 조치는 취하지 않으나, 시스템이 느려지는 등의 경우에 혹시 데드락이 있는지 detection을 하고 데드락 발견시 recover 한다.

### Detection

- single instance -> 자원할당 그래프의 cycle 존재 -> deadlock (O)

  - Wait-for graph : 자원할당 그래프에서 자원을 지우고 프로세스만 화살표로 연결한 그래프.

    ![image-20210328171330109](https://user-images.githubusercontent.com/77573938/112754638-f1c81000-9017-11eb-8e6b-db86b61f3009.png)

  - `P4 → P1` : P4가  P1이 가진 자원을 기다린다는 의미

  - 프로세스가 n개 있다고 할 때 Wait-for graph에서 cycle을 찾는데 O(n²)의 시간이 걸린다.

    - why? n개의 화살표에 가능한 사이클의 최대 개수 n-1개 -> n*(n-1)

<br>

- multiple instance -> Banker's algorithm과 유사한 방법 활용

[예시 1]

![image-20210328172901697](https://user-images.githubusercontent.com/77573938/112754639-f1c81000-9017-11eb-8c09-71e6b6806bd9.png)

- Deadlock Detection은 프로세스가 요청하면 그냥 자원을 다 준다. (즉, 프로세스의 최대 자원 요청 몰라도 됨)
- 데드락인지 아닌지 체크할 때는 반납했다고 가정하고 생각한다.
  - 현재 요청된게 없는 프로세스들부터 할당된 자원을 일단 반납한다고 가정한다.
  - P0가 B 1개를 갖고있지만 반납할 것이라고 가정. P2 역시 A 3개, C 3개 반납할 것이라고 가정. -> A 3개, B 1개, C 3개가 available해진다. 차례로 P3-> P1-> P4 할당.

<br>

[예시 2] 위와 동일한 조건에서 P2가 자원 C를 하나 더 요청한 상황

![image-20210328173955709](https://user-images.githubusercontent.com/77573938/112754640-f260a680-9017-11eb-8708-b760acc8e633.png)

- 자원요청을 안 한 프로세스는 P0밖에 없으므로, 완료 후 B 1개를 반납한다고 가정한다. 그러나 나머지 프로세스들이 B를 요청하지 않기 때문에 Deadlock이 존재한다. (P1, P2, P3, P4)
- 프로세스의 원칙 - 본인이 가진 자원은 가지고 있으면서 내가 요청한 자원이 만족될 때까지는 가진 자원을 반납하지 않음.



=> 데드락이 있는지 찾아볼 때는 

1. 가용자원(available)이 몇개 있는지 본 후, 처리 가능한 프로세스 먼저 체크한다. 
2. 현재 요청하지 않은 프로세스의 allocation은 가용자원으로 일단 다 합친다.
3. 그 후 처리가능한 프로세스를 체크한다.

<br>

### Recovery

데드락이 발견되면 Recover 해야한다.

- Process termination ; 프로세스 종료
  - 방법1. 데드락된 모든 프로세스들을 중단한다.
  - 방법2. 데드락 cycle이 제거 될 때까지 한 번에 하나의 프로세스를 중단해 나간다.
- Resource Preemption ; 데드락에 연루된 프로세스로 부터 자원을 뺏는 방법
  - 자원을 뺏을 프로세스는 비용을 최소화할 프로세스로 선정한다.
  - safe state로 rollback하여 process를 restart한다. == 자원을 뺏어 데드락을 없앤다.
  - Starvation 문제
    - 동일한 프로세스가 계속해서 victim으로 선정되는 경우
    - cost factor에 rollback 횟수도 같이 고려해야 한다.

<br><br>

## 4. Deadlock Ignorance

데드락에 대해 아무 일도 하지 않음

- **현대의 운영체제가 대부분 채택하고 있는 방식.** 데드락이 생기든 말든 관여하지 않는다.

  -> 그럼 데드락이 생겼을 때 어떻게 해결하는가? 

  사용자가 이상함을 느끼면 프로세스를 줄이는 방식으로 데드락을 해결한다. 

  **데드락은 빈번히 발생하지 않기 때문에 미연에 방지하기 위해 많은 오버헤드를 두는 것이 더 비효율적이다.**

