# File Systems Implementation (1)

<br>

# 1. Allocation of File Data in Disk

> 디스크에 파일의 데이터를 저장하는 방법
>
> 파일은 크기가 동일하지 않은데, 디스크에 저장할 때는 동일한 크기의 sector 단위(*논리적인 block*)로 나누어서 저장한다.

<br>

## Contiguous Allocation (연속 할당)

: 하나의 파일이 디스크 상에 연속해서 저장되는 방식

디렉토리 파일은 디렉토리 하의 파일들의 메타 데이터를 내용으로 한다.

![image-20210418104822257](https://user-images.githubusercontent.com/77573938/115136234-86db8900-a059-11eb-8797-78074aeb46cc.png)

- 단점

  - 외부 조각이 생길 수 있음. 

    각각의 파일들의 길이가 균일하지 않기 때문에 중간중간 free block의 공간(`hole`)이 불규칙하게 생김.

  - 파일의 크기를 키우는 데 제약이 있음. (파일을 수정하면서 파일의 크기가 커질 수 있다)

    어떤 파일이 커질 것을 대비해서 미리 빈 공간(hole)을 어느정도 확보할 수는 있지만, 그 크기만큼만 할당한 것이기 때문에 더이상 커지기는 어려움. & 미리 할당하면 당장 사용되지 않는 공간이기 때문에 내부 조각이 발생할 수 있음

    *cf )*

    - 외부조각 : 아무도 사용하지 않기 때문에 할당될 수 있는 공간
    - 내부조각 : 할당 됐는데 아직 사용되지 않는 공간

- 장점

  - 빠른 I/O 가능

    - 한번의 seek/rotation으로 많은 바이트 전송 가능

    - Realtime file용 or 이미 run 중이던 프로세스의 swapping용으로 사용 가능

      - swap area : 파일 저장이 아닌, 프로세스 주소공간 일부를 물리적인 메모리에서 쫒아내고, 나중에 필요할 때 올려놓는 용도로 사용하는 것.  프로세스가 끝나면 의미 없는 정보(임시로 저장)

        -> swapping용도는 공간 효율성보다는 속도 효율성이 더 중요한 데이터

  - 직접 접근(임의 접근)이 가능

<br>

## Linked Allocation (연결 할당)

: 파일의 데이터를 디스크에 연속적으로 배치하지 않고, 빈 위치 아무데나 들어갈 수 있게 배치하는 방식

(중간중간 균일하지 않은 hole들을 안 만들고자)

![image-20210418111633230](https://user-images.githubusercontent.com/77573938/115136235-86db8900-a059-11eb-86cf-1b083193a3ba.png)



- 장점
  - 외부 조각 발생 X
- 단점
  - 직접 접근(임의 접근) 불가능
  - Reliability 문제
    - 하나의 sector가 bad sector가 되어 pointer가 유실되면 이후 부분을 모두 잃어버리게 됨.
  - 포인터를 위한 공간이 block의 일부가 되어 공간 효율성을 떨어뜨린다. <- 크리티컬한 문제
    - 보통 디스크에서 하나의 sector는 512byte로 구성되고, 컴퓨터에서 디스크로 접근할 때 디스크에 데이터를 저장하려는 단위가 512byte의 배수로 구성되는데, 포인터가 4byte를 차지해서 비효율적이다.
- 변형해서 효율적으로 구현 할 수 있음 -> How?  **File-allocation table (FAT)** 파일 시스템
  - 포인터를 별도의 위치에 보관하여 reliability와 공간 효율성 문제를 해결

<br>

## Indexed Allocation (인덱스 할당)

: 디렉토리에 파일의 위치 정보 대신 `인덱스 블록` 값을 저장하는 방식

- 인덱스 블록 : 실제 파일의 내용을 담고 있는게 아니라, 파일이 저장된 위치 정보를 블록 하나에 열거하는 것

[그림]  jeep이라는 파일은 첫번째 블록이 9, 두번째 블록이 16, ..., 5번째 블록이 25이다.

4번째 블록을 보고 싶으면 9, 16, 1 블록을 통과하지 않고도, 인덱스 블록만으로 바로 10번 블록에 접근 가능하다.

![image-20210418113856811](https://user-images.githubusercontent.com/77573938/115136237-87741f80-a059-11eb-8728-cdebe2345f7b.png)

- 장점 <- 연속 할당 / 연결 할당의 단점을 모두 극복

  - 외부 조각 발생 X
  - 직접 접근(임의 접근) 가능

- 단점

  - 아무리 작은 파일이라도 블럭이 2개 필요함 (인덱스블록 & 실제 데이터를 저장하기 위한 블록)

    -> 작은 파일인 경우 공간이 낭비됨. (실제로 많은 파일들의 크기가 작음)

  - 너무 큰 파일인 경우 하나의 블록으로 인덱스를 저장하기에 부족

    - 해결 방안

      - 1. **linked scheme**

           인덱스 블록의 마지막 위치가 또다른 인덱스 블록을 가리키게 하는 것

      - 2. **multi-level index**

           인덱스 블록이 직접 파일의 위치를 가리키는게 아니라 또다른 인덱스를 가리키는 것 (2단계 페이징 테이블과 유사)

<br><br>

# 2. File System 구조

## UNIX 파일시스템

> 가장 기본적인 파일 시스템 구조
>
> 이 기본 구조를 바탕으로 점점 발전되어왔다.

![image-20210418120613692](https://user-images.githubusercontent.com/77573938/115136238-87741f80-a059-11eb-899a-d7b7a16047de.png)

- **Boot block**
  - 부팅에 필요한 정보(bootstrap loader)를 담고 있음.
  - UNIX 시스템뿐 아니라, 모든 파일 시스템에서 가장 먼저 나온다.
- **Super block**
  - 파일 시스템에 관한 총체적인 정보를 담고 있음.
  - 어디가 빈 블록이고 어디가 실제 사용 중인 블록인지, 어디까지 inode list가 있고 어디부터 data block인지를 관리.
- **Inode list**
  - 파일의 메타데이터는 그 파일을 가지고 있는 디렉토리에 기록되어 있음. but, 실제 파일시스템의 구현에서는 디렉토리가 메타데이터를 다 갖고 있지는 않음. **실제 메타데이터는 Inode list라는 별도의 위치에 따로 빼서 보관함.**
  - 파일 하나당 `Inode(Index-node)` 가 하나씩 할당됨. 
  - 이 Inode에 파일 이름을 제외한 파일의 모든 메타 데이터를 저장. (파일의 이름은 디렉토리가 가지고 있음)
  - UNIX 파일 시스템은 기본적으로 Indexed Allocation을 변형해서 사용하고, Inode는 크기가 고정되어 있다. → 위 정보를 나타내는 포인터 정보도 유한하다. 동시에 굉장히 큰 파일을 가급적 작은 inode를 가지고 표현해야해서 `direct blocks`, `single indirect`, `double indirect`, `triple indirect` 4가지로 파일의 위치정보를 구성한다.
  - 크기가 작은 파일의 경우 direct blocks만으로 파일의 위치 정보를 저장하고, 크기가 커질수록 더 많은 indirect 블록들을 함께 사용한다.
  - 일반적으로 파일의 크기가 작기 때문에 Inode 방식이 효율적이다.
- **Data block**
  - 메타 데이터 중 하나인 file 이름과 inode 번호는 data block 내의 디렉토리가 가지고 있음

<br>

## FAT 파일시스템

> Microsoft사가 MS DOS를 만들었을 때 처음 만든 파일 시스템
>
> 최근에 Windows 계열에서 일부 사용, 모바일 기기에서도 사용하는 경우 있음.

![image-20210418121338722](https://user-images.githubusercontent.com/77573938/115136240-880cb600-a059-11eb-9c5a-4c1be6c4d9d5.png)

- **Boot block**

- **FAT**

  - 파일의 메타데이터 중 위치정보 만을 보관. (나머지 메타데이터는 디렉토리가 가지고 있음)

  - Data block이 관리하는 블럭의 개수만큼 배열을 만들어 다음 블록의 번호를 저장한다.

    **→ 직접 접근 가능**

  - Linked Allocation 방식을 활용하지만 Linked Allocation의 단점을 모두 극복 (랜덤접근 가능, reliability 문제 해결)

    - 포인터 하나가 유실되더라도(==bad sector가 발생하더라도) FAT에 정보가 남아 있기 때문에 reliability 문제가 개선됨 (FAT과 Data block의 정보는 별개임)

- **Root directory**

- **Data block**
  
  - 위치정보를 제외한 모든 메타데이터를 가지고 있음. (파일의 첫 번째 위치 정보도 저장하고 있음)

<br><br>

## Free-Space Management

> 비어있는 블록을 관리하는 방법

<br>

### Bit map / Bit vector

![image-20210418125108142](https://user-images.githubusercontent.com/77573938/115136241-880cb600-a059-11eb-914d-e928f3c9c988.png)

- 비어 있으면 0, 파일에 할당되어 있으면 1로 표시
- 파일시스템은 새로운 파일이 만들어지거나 파일의 크기가 커지는 경우 비어있는 블록 중 하나를 할당하고, 파일이 삭제되면 1로 표시된 bit map을 0으로 바꾸어줌.
- Bit map은 부가적인 공간을 필요로 함
- 연속적인 n개의 free block을 찾는데 효과적

<br>

### Linked list

>  회색이 비어있는 블록

![image-20210418125541227](https://user-images.githubusercontent.com/77573938/115136243-88a54c80-a059-11eb-86de-2bea8eb09d46.png)

- 모든 free block들을 링크로 연결 (free list)
- 어차피 비어있는 공간이기 때문에 포인터를 가지고 다음에 비어있는 블록의 위치를 저장할 수 있음
- 비어있는 블록의 첫번째 위치만 포인터로 가지고 있음
- 장점 : 공간 낭비가 없음
- 단점 : 연속적인 가용공간(빈공간)을 찾는 것이 쉽지 않음

<br>

### Grouping

- linked list 방법의 변형
- 첫 번째 free block이 n개의 포인터를 가짐
  - `n-1` 포인터는 free data block을 가리킴
  - 마지막 포인터가 가리키는 블록은 또 다시 `n` 포인터를 가짐
- 비어있는 블록을 한꺼번에 찾기에는 linked list보다는 효율적이지만 연속적인 빈 블록을 찾기에 썩 효과적이진 않음

<br>

### Counting

- 연속적인 빈 블록을 찾기에 적합한 방법

- 프로그램들이 종종 여러 개의 연속적인 블록을 할당하고 반납한다는 성질에 착안

- 연속적인 빈 블록을 표시하기 위해 빈블록의 첫번째에 위치(first free block)하고, 그 블록에서부터 몇 개의 블록이 비어있는지를 쌍으로 관리함.

<br><br>

## Directory 구현

> 디렉토리 : 그 디렉토리 밑에 있는 파일의 메타데이터를 관리하는 특별한 파일

![image-20210418130548968](https://user-images.githubusercontent.com/77573938/115136245-88a54c80-a059-11eb-98d2-0442bc72aff2.png)

- **Linear List**
  - <파일이름, 파일의 메타데이터>의 리스트
  - 메타데이터는 크기 고정되어 있음
  - 구현이 간단
  - 디렉토리 내에 파일이 있는지 찾기 위해서는 선형 탐색이 필요하므로, 시간이 많이 걸림 -> 비효율적
- **Hash Table**
  - 파일의 이름을 그냥 저장하는게 아니라 해시함수를 적용함 -> 값이 특정범위로 한정됨
  - linear list + hashing
  - Hash Table은 파일 이름을 이 파일의 linear list의 위치로 바꾸어줌
  - 탐색 시간을 없앤다.
  - 충돌(Collision)이 발생할 수 있음

<br>

#### 파일의 메타 데이터의 보관 위치

- 1) 디렉토리 내에 직접 보관
- 2) 디렉토리에는 포인터를 두고 다른 곳에 보관
  - UNIX 파일 시스템의 inode, FAT 파일 시스템의 FAT 등

<br>

#### 긴 파일 이름의 지원

![image-20210418135719511](https://user-images.githubusercontent.com/77573938/115136246-893de300-a059-11eb-80be-f83dbfc3415c.png)

- <file name, file의 metadata>의 리스트에서 각 entry는 일반적으로 고정 크기
- file name이 고정 크기의 entry 길이보다 길어지는 경우 entry의 마지막 부분에 이름의 뒷부분이 위치한 곳의 포인터를 두는 방법
- 이름의 나머지 부분은 동일한 디렉토리 파일의 일부에 존재

<br><br>

---

## VFS and NFS

사용자가 파일시스템을 접근할 때는 운영체제한테 시스템을 해야함.

파일시스템 별로 서로 다른 시스템콜 인터페이스를 써야한다면 사용자가 굉장히 혼란스러움 → 어떤 파일시스템이 사용되던 상관없이 개별 파일시스템 윗계층에 VFS라는 인터페이스를 하나 둠.

![image-20210418140211408](https://user-images.githubusercontent.com/77573938/115136248-893de300-a059-11eb-8501-adb0a3346724.png)



### Virtual File System (VFS)

- 서로 다른 다양한 파일시스템에 대해 동일한 시스템 콜 인터페이스(API)를 통해 접근할 수 있게 해주는 OS의 계층

### Network File System (NFS)

- 로컬 외에 원격에 저장된 파일시스템에 접근하는 경우 NFS 인터페이스를 사용하여 접근
- 분산 시스템에서는 네트워크를 통해 파일이 공유될 수 있음
- NFS는 분산 환경에서의 대표적인 파일 공유 방법이다.




