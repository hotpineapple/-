# 검색
- 주어진 데이터 셋에서 내가 원하는 데이터가 있는지, 어디에 있는지를 찾는 것
- 최악의 경우 O(N)
- 데이터가 정렬되어 있으면 검색이 빠르다

## 더 빠르게 검색하는 알고리즘
- 무순서 선형검색 : O(N)
- 정렬/순서 선형검색 : O(N)
- 이진검색 (정렬 전제) : O(logN)
- 해싱 : O(1)

### 무순서 선형검색
- 전체 배열을 스캔

### 정렬/순서 선형검색
- 유무 판단 : 찾으려는 값과 비교값을 대소비교하여 판단 가능
    - 예) [1,3,5,7,9] 에서 6을 찾는 경우 7에서 그만 찾음

### 이진검색
- 중간값과 비교, 그 결과에따라 앞 절반의 중간값 또는 뒤 절반의 중간값과 비교를 반복함
- iterative / recursive

### 해싱
-  예
    - 컴퓨터는 시간싸움
    - 멀티 프로세싱 -> 가상메모리 사용
    - 가상메모리 주소값 매핑 TLB(CPU에 포함-CPU 속도에 맞춰야 함) 의 요구사항: 상수시간 검색 
- ADT
    - Create
    - Insert
    - Search
    - Delete

#### 해싱 이해하기
- 문자열에서 처음 반복되는 문자 찾는 최적 알고리즘
    - 배열생성 후 아스키코드 값에 해당하는 인덱스의 값에 카운트 +1 
- 왜 Direct addressing 을 안쓰지?
    - 키를 인덱스로 바로 사용할 경우 실제 사용되는 키의 범위에 비해 매우 큰 크기의 배열이 필요함
    - 해시함수로 키를 인덱스로 변환해서 실제 사용되는 범위만큼만 사용 (=해시 테이블)
- 충돌 
    - 다른 키값이 같은 인덱스에 저장되는 것
- 충돌 해결
    - 연결리스트와 해시테이블의 결합
        - 단점: 추가적인 자료구조가 필요, 검색 시간복잡도: 최악의 경우 O(N)
    - 오픈 어드레싱
        - 선형탐사
            - 삽입 시간복잡도? 최악의 경우 O(N)
            - 검색 시간복잡도? 최악의 경우 O(N)
        - 2차탐사
        - 2중 해싱
            - 또 충돌난다면? -> 연결리스트를 사용해야 할 것 같음
        - 단점: 클러스터링(충돌된 해시값 인덱스 주변 인덱스에 데이터가 모여 있어서 빈 공간을 찾는 데에 시간이 소요됨) 

#### 해시 잘 이용하기 = O(1) 시간복잡도로 이용하기
- 여러 개의 항목이 같은 위치에 할당될 때(=충돌 발생) 어떻게 해싱이 "평균" O(1)의 시간복잡도를 갖는가?
- 적재율(해시테이블의 사용된 항목개수/해시테이블크기)이 적절하고 대부분의 key를 해시테이블에 골고루 분배할 수 있는 해시함수를 갖는 경우
- 평균적으로 각 블록(예-연결리스트)의 항목 수가 적재율과 비슷한 경우

#### 좋은 해시함수 관찰 결과
- 쉽고빠른 계산 가능
- 충돌 최소화
- 키를 균등하게 분배
- 키의 모든 정보를 사용
- 높은 적재율(=효율성)을 가짐
