# 해싱
- 최악 O(N), 평균 O(1)

## 해싱 이해하기
- 문자열에서 처음 반복되는 문자 찾는 최적 알고리즘
    - 배열생성 후 아스키코드 값에 해당하는 인덱스의 값에 카운트 +1 
- 왜 Direct addressing 을 안쓰지?
    - 키를 인덱스로 바로 사용할 경우 실제 사용되는 키의 범위에 비해 매우 큰 크기의 배열이 필요함
    - 해시함수로 키를 인덱스로 변환해서 실제 사용되는 범위만큼만 사용 (=해시 테이블)
- 충돌 
    - 다른 키값이 같은 인덱스에 저장되는 것
- 충돌 해결
    - 연결리스트와 해시테이블의 결합
        - 검색 시간복잡도? 최악의 경우 O(N)
    - 오픈 어드레싱
        - 선형탐사
            - 삽입 시간복잡도? 최악의 경우 O(N)
            - 검색 시간복잡도? 최악의 경우 O(N)
        - 2차탐사
        - 2중 해싱
            - 또 충돌난다면? -> 연결리스트를 사용해야 할 것 같음

## 해시 잘 이용하기 = O(1) 시간복잡도로 이용하기
- 여러 개의 항목이 같은 위치에 할당될 때(=충돌 발생) 어떻게 해싱이 "평균" O(1)의 시간복잡도를 갖는가?
- 적재율(해시테이블의 사용된 항목개수/해시테이블크기)이 적절하고 대부분의 key를 해시테이블에 골고루 분배할 수 있는 해시함수를 갖는 경우
- 평균적으로 각 블록(예-연결리스트)의 항목 수가 적재율과 비슷한 경우

## 좋은 해시함수 관찰 결과
- 쉽고빠른 계산 가능
- 충돌 최소화
- 키를 균등하게 분배
- 키의 모든 정보를 사용
- 높은 적재율(=효율성)을 가짐
